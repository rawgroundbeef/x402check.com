---
phase: 08-validation-rules-and-orchestrator
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/x402check/src/validation/rules/structure.ts
  - packages/x402check/src/validation/rules/version.ts
  - packages/x402check/src/validation/rules/fields.ts
  - packages/x402check/src/validation/rules/network.ts
  - packages/x402check/src/validation/rules/amount.ts
  - packages/x402check/src/validation/rules/legacy.ts
  - packages/x402check/src/validation/rules/index.ts
autonomous: true

must_haves:
  truths:
    - "Each rule module returns ValidationIssue[] and never throws"
    - "Structure validation catches non-JSON, non-object, and unknown format inputs"
    - "Version validation checks x402Version presence and value"
    - "Fields validation checks all required accepts entry fields (scheme, network, amount, asset, payTo)"
    - "Network validation checks CAIP-2 format and provides fix suggestions for simple names"
    - "Amount validation rejects non-numeric strings and zero amounts"
    - "Legacy validation produces warnings for flat-legacy format, v1 field names, and simple chain names"
  artifacts:
    - path: "packages/x402check/src/validation/rules/structure.ts"
      provides: "Level 1 structure validation (JSON parse, object check, format detection)"
      exports: ["validateStructure"]
    - path: "packages/x402check/src/validation/rules/version.ts"
      provides: "Level 2 version validation (x402Version presence and value)"
      exports: ["validateVersion"]
    - path: "packages/x402check/src/validation/rules/fields.ts"
      provides: "Level 3 required field validation per accepts entry"
      exports: ["validateFields"]
    - path: "packages/x402check/src/validation/rules/network.ts"
      provides: "Level 4 CAIP-2 format and known network validation"
      exports: ["validateNetwork"]
    - path: "packages/x402check/src/validation/rules/amount.ts"
      provides: "Level 4 numeric string and positive amount validation"
      exports: ["validateAmount"]
    - path: "packages/x402check/src/validation/rules/legacy.ts"
      provides: "Level 5 legacy format warnings with fix suggestions"
      exports: ["validateLegacy"]
    - path: "packages/x402check/src/validation/rules/index.ts"
      provides: "Barrel export for all rule modules"
  key_links:
    - from: "packages/x402check/src/validation/rules/structure.ts"
      to: "packages/x402check/src/types/parse-input.ts"
      via: "import parseInput"
      pattern: "import.*parseInput"
    - from: "packages/x402check/src/validation/rules/network.ts"
      to: "packages/x402check/src/registries/networks.ts"
      via: "import isValidCaip2, isKnownNetwork"
      pattern: "import.*isValidCaip2"
    - from: "packages/x402check/src/validation/rules/network.ts"
      to: "packages/x402check/src/registries/simple-names.ts"
      via: "import getCanonicalNetwork for fix suggestions"
      pattern: "import.*getCanonicalNetwork"
---

<objective>
Create all validation rule modules that the orchestrator will compose into the validate() pipeline.

Purpose: Each rule module is a pure function that takes config/entry data and returns ValidationIssue[]. These are the building blocks the orchestrator (Plan 02) will compose. Separating rules into modules enables unit testing of each rule and prevents the orchestrator from becoming a monolith.

Output: 7 files in `packages/x402check/src/validation/rules/` -- 6 rule modules + 1 barrel export.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-validation-rules-and-orchestrator/08-RESEARCH.md

@packages/x402check/src/types/errors.ts
@packages/x402check/src/types/validation.ts
@packages/x402check/src/types/config.ts
@packages/x402check/src/types/parse-input.ts
@packages/x402check/src/registries/networks.ts
@packages/x402check/src/registries/simple-names.ts
@packages/x402check/src/registries/assets.ts
@packages/x402check/src/detection/detect.ts
@packages/x402check/src/detection/guards.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create structure, version, and fields rule modules</name>
  <files>
    packages/x402check/src/validation/rules/structure.ts
    packages/x402check/src/validation/rules/version.ts
    packages/x402check/src/validation/rules/fields.ts
  </files>
  <action>
Create three rule modules in `packages/x402check/src/validation/rules/`:

**structure.ts** - Level 1 validation. Export `validateStructure(input: string | object)` which returns `{ parsed: object | null, format: ConfigFormat, issues: ValidationIssue[] }`. This function:
1. Calls `parseInput(input)` from `../../types/parse-input`. If parse error, return `{ parsed: null, format: 'unknown', issues: [parseError] }`.
2. Checks the parsed value is a non-null, non-array object using `isRecord()` from `../../detection/guards`. If not, push issue with `ErrorCode.NOT_OBJECT`, field `'$'`, severity `'error'`.
3. Calls `detect(parsed as object)` from `../../detection/detect`. If `'unknown'`, push issue with `ErrorCode.UNKNOWN_FORMAT`, field `'$'`, severity `'error'`.
4. Return `{ parsed, format, issues }`.

Note: `validateStructure` has a different return type than other rules because the orchestrator needs the parsed object and detected format. Define the return type inline as `StructureResult`.

**version.ts** - Level 2 validation. Export `validateVersion(config: NormalizedConfig, detectedFormat: ConfigFormat)` returning `ValidationIssue[]`. This function:
1. Checks `config.x402Version`. Since normalize() always sets `x402Version: 2`, this mainly validates the original format's version field. But if somehow the value isn't 1 or 2, push `INVALID_VERSION` error.
2. No `MISSING_VERSION` check needed here because normalize() always sets it. The orchestrator handles version-related warnings for legacy formats via the legacy rule module.

**fields.ts** - Level 3 validation. Export `validateFields(entry: AcceptsEntry, fieldPath: string)` returning `ValidationIssue[]`. Check each required field:
- `scheme`: If missing/empty string, push `MISSING_SCHEME` error at `${fieldPath}.scheme`
- `network`: If missing/empty string, push `MISSING_NETWORK` error at `${fieldPath}.network`
- `amount`: If missing/empty string, push `MISSING_AMOUNT` error at `${fieldPath}.amount`
- `asset`: If missing/empty string, push `MISSING_ASSET` error at `${fieldPath}.asset`
- `payTo`: If missing/empty string, push `MISSING_PAY_TO` error at `${fieldPath}.payTo`

Also export `validateAccepts(config: NormalizedConfig)` returning `ValidationIssue[]`:
- If `config.accepts` is not an array, push `INVALID_ACCEPTS` at `'accepts'`
- If array is empty, push `EMPTY_ACCEPTS` at `'accepts'`

Also export `validateResource(config: NormalizedConfig, detectedFormat: ConfigFormat)` returning `ValidationIssue[]`:
- If `detectedFormat === 'v2'` and `!config.resource`, push `MISSING_RESOURCE` as warning at `'resource'` (resource is expected in v2 but its absence is a warning, not error, since some v2 configs work without it)
- If `config.resource` exists and `config.resource.url` is empty string or not present, push `MISSING_RESOURCE` as warning at `'resource.url'`

All modules import types from `../../types` and error codes from `../../types/errors`. Use `exactOptionalPropertyTypes`-compliant patterns (`fix?: string | undefined`).
  </action>
  <verify>
Run `cd /Users/rawgroundbeef/Projects/x402check && npx tsc --noEmit -p packages/x402check/tsconfig.json` -- no type errors.
  </verify>
  <done>
Three rule modules compile with zero errors. Each exports pure functions returning ValidationIssue[]. Structure returns a richer result type with parsed object and format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create network, amount, and legacy rule modules with barrel export</name>
  <files>
    packages/x402check/src/validation/rules/network.ts
    packages/x402check/src/validation/rules/amount.ts
    packages/x402check/src/validation/rules/legacy.ts
    packages/x402check/src/validation/rules/index.ts
  </files>
  <action>
Create four files in `packages/x402check/src/validation/rules/`:

**network.ts** - Level 4 validation. Export `validateNetwork(entry: AcceptsEntry, fieldPath: string)` returning `ValidationIssue[]`:
1. If `!entry.network` or empty string, return [] (missing field already caught by validateFields).
2. If `!isValidCaip2(entry.network)`: Check if `getCanonicalNetwork(entry.network)` returns a CAIP-2 ID. If yes, push error with `INVALID_NETWORK_FORMAT`, include `fix: "Use '${canonical}' instead of '${entry.network}'"`. If no canonical mapping, push `INVALID_NETWORK_FORMAT` error without fix.
3. If valid CAIP-2 but `!isKnownNetwork(entry.network)`: push `UNKNOWN_NETWORK` warning (severity `'warning'`).
4. Import `isValidCaip2`, `isKnownNetwork` from `../../registries/networks`, and `getCanonicalNetwork` from `../../registries/simple-names`.

Also export `validateAsset(entry: AcceptsEntry, fieldPath: string)` returning `ValidationIssue[]`:
1. If `!entry.asset` or empty, return [] (missing caught by validateFields).
2. If entry has a valid network and `!isKnownAsset(entry.network, entry.asset)`, push `UNKNOWN_ASSET` warning.
3. Import `isKnownAsset` from `../../registries/assets`.

**amount.ts** - Level 4 validation. Export `validateAmount(entry: AcceptsEntry, fieldPath: string)` returning `ValidationIssue[]`:
1. If `!entry.amount` or empty string, return [] (missing caught by validateFields).
2. If amount does NOT match `/^\d+$/` (digits only -- no decimals, no signs, no scientific notation), push `INVALID_AMOUNT` error at `${fieldPath}.amount` and return early.
3. If amount is `'0'`, push `ZERO_AMOUNT` error at `${fieldPath}.amount`.

Also export `validateTimeout(entry: AcceptsEntry, fieldPath: string, detectedFormat: ConfigFormat)` returning `ValidationIssue[]`:
1. If `entry.maxTimeoutSeconds === undefined` and `detectedFormat === 'v2'`, push `MISSING_MAX_TIMEOUT` warning.
2. If `entry.maxTimeoutSeconds` is present but not a positive integer (`typeof !== 'number'` or `<= 0` or not `Number.isInteger()`), push `INVALID_AMOUNT` error (reuse code) at `${fieldPath}.maxTimeoutSeconds` with message "maxTimeoutSeconds must be a positive integer". Actually -- there is no specific error code for invalid timeout. Use a custom approach: push a ValidationIssue with code `INVALID_AMOUNT` is wrong. Instead, just skip the invalid-timeout check for now since there's no error code for it. Only push the `MISSING_MAX_TIMEOUT` warning when absent in v2 format.

**legacy.ts** - Level 5 validation. Export `validateLegacy(config: NormalizedConfig, detectedFormat: ConfigFormat, originalInput: object)` returning `ValidationIssue[]`:
1. If `detectedFormat === 'flat-legacy'`, push `LEGACY_FORMAT` warning at `'$'` with `fix: 'Upgrade to x402 v2 format with accepts[] array'`.
2. If `detectedFormat === 'v1'`, push `LEGACY_FORMAT` warning at `'$'` with `fix: 'Upgrade to x402 v2 -- use amount instead of maxAmountRequired, add resource object'`.
3. Check the original input for simple chain names: if `originalInput` has any `accepts` entries (or flat fields) where the network value is NOT valid CAIP-2 but IS a known simple name (via `getCanonicalNetwork`), push a warning with `LEGACY_FORMAT` at the relevant field path with `fix: "Use '${canonical}' instead of '${simpleName}'"`. However, since normalization already converts simple names to CAIP-2, this situation only arises for flat-legacy and v1 configs. The warning is about the original input format, not the normalized one. For v2 configs with invalid CAIP-2 networks, the network rule module already handles it.

Actually, simplify legacy.ts: Since `normalize()` already converts simple names to CAIP-2, and `validateNetwork()` already catches invalid CAIP-2 with fix suggestions, legacy.ts only needs to emit the format-level legacy warning. Don't duplicate the simple name check here.

**index.ts** - Barrel export. Re-export all functions from the six modules:
```
export { validateStructure } from './structure'
export type { StructureResult } from './structure'
export { validateVersion } from './version'
export { validateFields, validateAccepts, validateResource } from './fields'
export { validateNetwork, validateAsset } from './network'
export { validateAmount, validateTimeout } from './amount'
export { validateLegacy } from './legacy'
```
  </action>
  <verify>
Run `cd /Users/rawgroundbeef/Projects/x402check && npx tsc --noEmit -p packages/x402check/tsconfig.json` -- no type errors. Verify all 7 files exist: `ls packages/x402check/src/validation/rules/`.
  </verify>
  <done>
All 6 rule modules + barrel export compile. Network validation provides CAIP-2 fix suggestions via getCanonicalNetwork. Amount validates digit-only strings and non-zero. Legacy emits format-level warnings. All functions are pure, return ValidationIssue[], never throw.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/rawgroundbeef/Projects/x402check && npx tsc --noEmit -p packages/x402check/tsconfig.json` passes with zero errors
2. All 7 files exist in `packages/x402check/src/validation/rules/`
3. Each module imports from existing Phase 6-7 code (types, registries, detection) -- no new dependencies
4. No circular imports between rule modules
</verification>

<success_criteria>
- All 6 rule modules export pure validator functions returning ValidationIssue[]
- validateStructure returns enriched result with parsed object and format
- validateNetwork provides fix suggestions for simple chain names
- validateAmount validates digit-only numeric strings and rejects zero
- validateLegacy warns about flat-legacy and v1 formats
- Zero TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-validation-rules-and-orchestrator/08-01-SUMMARY.md`
</output>
